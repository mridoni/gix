/*
This file is part of Gix-IDE, an IDE and platform for GnuCOBOL
Copyright (C) 2021 Marco Ridoni

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
USA.
*/

#pragma once

// CHANGE: added <fstream> for new std::ifstream member "instream":
#include <fstream>
#include <string>
#include <map>

// Generated by bison:
#include "gix_esql_parser.hh"

// CHANGE: replaced `#define YY_DECL ...` here with #include of new
// lexer class:
#include "GixEsqlLexer.hh"

#include "ESQLDefinitions.h"
#include "GixPreProcessor.h"

#define PIC_ALPHABETIC 		0x01
#define PIC_NUMERIC 		0x02
#define PIC_NATIONAL		0x04
#define PIC_ALPHANUMERIC	(PIC_ALPHABETIC | PIC_NUMERIC)

// Conducting the whole scanning and parsing of Calc++.
class gix_esql_driver
{
public:
    gix_esql_driver ();
    virtual ~gix_esql_driver ();

#pragma region Options

    // We only have here the flags connected to parsing, other flags
    // are handled in the code generation module
    bool opt_preprocess_copy_files;
    bool opt_use_anonymous_params;

#pragma endregion

#pragma region Parse/Scanner stuff
    int result;
    
    // CHANGE: add lexer object as a member
    GixEsqlLexer lexer;

    // CHANGE: add ifstream object as a member
    std::ifstream instream;

    // Handling the scanner.
    void scan_begin ();
    void scan_end ();
    bool trace_scanning;
    
    // Run the parser on file F.
    // Return 0 on success.
    int parse (GixPreProcessor *gpp, const std::string& f);
    // The name of the file being parsed.
    // Used later to pass the file name to the location tracker.
    std::string file;
    // Whether parser traces should be generated.
    bool trace_parsing;

    // Error handling.
    void error (const yy::location& l, const std::string& m, int err_code = 1);
    void error (const std::string& m, int err_code = 1);

#pragma endregion


#pragma region ESQL data structures

    std::vector<cb_sql_token_t> *cb_text_list_add(std::vector<cb_sql_token_t> *list, std::string text);
    std::vector<cb_sql_token_t> *cb_concat_text_list(std::vector<cb_sql_token_t> *list, std::vector<cb_sql_token_t> *targetlist);

    std::string cb_host_list_add(std::vector<cb_hostreference_ptr> *list, std::string text);
    std::string cb_host_list_add_force(std::vector<cb_hostreference_ptr> *list, std::string text);
    
    void cb_res_host_list_add(std::vector<cb_res_hostreference_ptr> *list, std::string text);
    
    int cb_search_list(std::string text);
    
    void cb_set_cursorname(std::string text);
    void cb_set_commandname(std::string text);
    void cb_set_cursor_hold(bool h);

    int build_picture(const std::string str, cb_field_ptr pic);
    cb_field_ptr cb_build_field_tree(int level, std::string, cb_field_ptr last_field);

    void put_startup_exec_list();
    void put_exec_list();

    int startlineno;
    int endlineno;
    int hostlineno;
    int period;
    int sqlnum;
    int command_putother;
    std::string filenameID;
    int currenthostno;
    int cursor_hold;
    std::string commandname;
    std::string cursorname;
    std::string sqlname;
    std::string incfilename;

    hostref_or_literal_t *connectionid = nullptr;

    int orig_state = 0;

    int hostreferenceCount;
    std::vector<cb_hostreference_ptr> *host_reference_list;
    std::vector<cb_res_hostreference_ptr> *res_host_reference_list;
    std::vector<cb_sql_token_t> *sql_list;
    std::vector<cb_exec_sql_stmt_ptr> *exec_list;

    cb_field_ptr current_field;
    cb_field_ptr description_field;

    esql_connection_info_t *conninfo = nullptr;

    bool has_esql_in_cbl_copybooks;
    bool procedure_division_started = false;

    bool in_ws_section = false;
    bool in_linkage_section = false;
    bool in_file_section = false;

#pragma endregion

#pragma region Management
    GixPreProcessor *pp_inst;
    
    std::map<std::string, cb_field_ptr> field_map;
    std::map<std::string, std::tuple<uint64_t, int, int>> field_sql_type_info;

    std::map<std::string, srcLocation> paragraphs;

    std::string program_id;

#pragma endregion

};
