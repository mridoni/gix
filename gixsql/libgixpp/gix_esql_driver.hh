/*
This file is part of Gix-IDE, an IDE and platform for GnuCOBOL
Copyright (C) 2021 Marco Ridoni

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
USA.
*/

#pragma once

// CHANGE: added <fstream> for new std::ifstream member "instream":
#include <fstream>
#include <string>
#include <map>

// Generated by bison:
#include "gix_esql_parser.hh"

// CHANGE: replaced `#define YY_DECL ...` here with #include of new
// lexer class:
#include "GixEsqlLexer.hh"

#include "ESQLDefinitions.h"
#include "GixPreProcessor.h"

#define PIC_ALPHABETIC 		0x01
#define PIC_NUMERIC 		0x02
#define PIC_NATIONAL		0x04
#define PIC_ALPHANUMERIC	(PIC_ALPHABETIC | PIC_NUMERIC)

#define DD_SECTION_INITIAL  0   // INITIAL
#define DD_SECTION_FS       1   // FILE SECTION
#define DD_SECTION_WS       2   // WORKING-STORAGE SECTION
#define DD_SECTION_LL       3   // LOCAL-STORAGE SECTION
#define DD_SECTION_LS       4   // LINKAGE SECTION

#define ERR_PP_PARAM_ERROR      18000
#define ERR_SYNTAX_ERROR        19000
#define ERR_MISSING_HOSTVAR     19100
#define ERR_MISSING_COPYFILE    19101
#define ERR_CRSR_GEN            19102
#define ERR_INVALID_LEVEL       19103
#define ERR_INCOMPATIBLE_TYPES  19104
#define ERR_MISSING_LENGTH      19105
#define ERR_INVALID_TYPE        19106
#define ERR_FILE_NOT_FOUND      19107
#define ERR_QUERY_TOO_LONG      19108
#define ERR_INVALID_DATA        19109

// This is used to keep the error code from nested function
#define ERR_ALREADY_SET         -9999

void decode_sql_type_info(uint64_t type_info, uint32_t* sql_type, uint32_t* precision, uint16_t* scale, uint8_t* flags);
uint64_t encode_sql_type_info(uint32_t sql_type, uint32_t precision, uint16_t scale, uint8_t flags);

enum class ESQL_ParameterStyle {
    DollarPrefix,
    ColonPrefix,
    Anonymous,
    Unknown
};

class TPESQLProcessing;

// Conducting the whole scanning and parsing of Calc++.
class gix_esql_driver
{
public:
    gix_esql_driver ();
    virtual ~gix_esql_driver ();

    void setCaller(TPESQLProcessing* p);

#pragma region Options

    // We only have here the flags connected to parsing, other flags
    // are handled in the code generation module
    bool opt_preprocess_copy_files;
    ESQL_ParameterStyle opt_params_style;

#pragma endregion

#pragma region Parse/Scanner stuff
    int result;
    
    // CHANGE: add lexer object as a member
    GixEsqlLexer lexer;

    // CHANGE: add ifstream object as a member
    std::ifstream instream;

    // Handling the scanner.
    void scan_begin ();
    void scan_end ();
    bool trace_scanning;
    
    // Run the parser on file F.
    // Return 0 on success.
    int parse (GixPreProcessor *gpp, const std::string& f);
    // The name of the file being parsed.
    // Used later to pass the file name to the location tracker.
    std::string file;
    // Whether parser traces should be generated.
    bool trace_parsing;

    // Error handling.
    void error (const yy::location& l, const std::string& m, int err_code, std::string filename = std::string(), int line = -1);
    void error (const std::string& m, int err_code, std::string filename = std::string(), int line = -1);
    void warning(const yy::location &l, const std::string &m);
    void warning(const std::string &m);

#pragma endregion


#pragma region ESQL data structures

    std::vector<cb_sql_token_t> *cb_text_list_add(std::vector<cb_sql_token_t> *list, std::string text);
    std::vector<cb_sql_token_t> *cb_concat_text_list(std::vector<cb_sql_token_t> *list, std::vector<cb_sql_token_t> *targetlist);

    std::string cb_host_list_add(std::vector<cb_hostreference_ptr> *list, std::string text);
    std::string cb_host_list_add_force(std::vector<cb_hostreference_ptr> *list, std::string text);
    
    void cb_res_host_list_add(std::vector<cb_res_hostreference_ptr> *list, std::string text);
    
    int cb_search_list(std::string text);
    
    void cb_set_cursorname(std::string text);
    void cb_set_commandname(std::string text);
    void cb_set_cursor_hold(bool h);

    int build_picture(const std::string str, cb_field_ptr pic);
    cb_field_ptr cb_build_field_tree(int level, std::string, cb_field_ptr last_field);

    void put_startup_exec_list();
    void put_exec_list();

    int startlineno;
    int endlineno;
    int hostlineno;
    int period;
    int sqlnum;
    int command_putother;
    std::string filenameID;
    int currenthostno = 0;
    int cursor_hold = 0;
    std::string commandname;
    std::string cursorname;
    std::string sqlname;
    std::string incfilename;
    std::string text_content;
    bool transaction_release;

    hostref_or_literal_t *connectionid = nullptr;
    
    std::string statement_name;
    hostref_or_literal_t *statement_source = nullptr;

    int orig_state = 0;

    int hostreferenceCount;
    std::vector<cb_hostreference_ptr> *host_reference_list;
    std::vector<cb_res_hostreference_ptr> *res_host_reference_list;
    std::vector<cb_sql_token_t> *sql_list;
    std::vector<cb_exec_sql_stmt_ptr> *exec_list;
    std::vector<hostref_or_literal_t *> *hostref_or_literal_list;

    std::vector<std::string> declared_statements;

    cb_field_ptr current_field;
    cb_field_ptr description_field;

    esql_connection_info_t *conninfo = nullptr;
    esql_whenever_data_t* whenever_data = nullptr;

    bool has_esql_in_cbl_copybooks;
    bool procedure_division_started = false;
    bool in_ignore_string = false;

    int data_division_section = DD_SECTION_INITIAL;

#pragma endregion

#pragma region Management
    GixPreProcessor *pp_inst = nullptr;
    TPESQLProcessing* pp_caller = nullptr;
    
    std::map<std::string, cb_field_ptr> field_map;
    std::map<std::string, std::tuple<uint64_t, int, int, std::string>> field_sql_type_info;

    std::map<std::string, srcLocation> paragraphs;

    std::string program_id;

    bool field_exists(const std::string &f);

#pragma endregion

};
